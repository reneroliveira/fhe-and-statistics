\chapter{Algebraic Review}
\label{ch:algebra}

In this chapter, we shall discuss the algebraic theoretical background that grounds cryptography schemes. Section \ref{sec:basics} defines basic algebraic structures such as groups and rings. Section \ref{sec:homo} goes through homomorphism properties and quotient rings, two important concepts. Section \ref{sec:cyc} explains cyclotomic polynomials, a special type of polynomial that will be used in the next section and chapter. Section \ref{sec:lattices} defines lattices, an algebraic structure with interesting computationally hard problems that will guarantee the security of our encryption schemes.

\section{Basic structures}\label{sec:basics}
% groups, quotient groups, cosets, rings, quotient rings, fields

\begin{definition}[Group]

A non-empty set G is called a group under the operation $*$, if it satisfies the following axioms:

\begin{alineas}
    \item  (Closure) $G$ is closed under $*$, i.e, for all $a,b\in G$, the result $a*b$ is also in $G$;
    \item (Associativity) $(a* b)* c = a* (b*c)$, for all $a,b,c\in G$;
    \item (Existence of identity) There exists $e\in G$ such that $a*e=e*a=a$ for all $a\in G$;
    \item (Existence of inverse) There exists $a^{-1}\in G$ such that $a*a^{-1}=a^{-1}*a=e$ for all $a\in G$;
    
    We shall denote the group as $(G,*)$. If, in addition to the above axioms, the group also satisfies the next property, it is called an \textbf{abelian group}.
    
    \item (Commutativity) For all $a,b\in G$, $a*b=b*a$.
\end{alineas}
\end{definition}

Examples of abelian groups\footnote{$\mathbb{Q}^{\times}=\mathbb{Q}/\{0\}$}: $(\mathbb{Z},+)$ with identity element $0$ and inverse of $a$ being $-a$. $(\mathbb{Q}^\times,\cdot)$ with identity $1$ and inverse $a^{-1}=1/a$.

\begin{definition}[Subgroup]\label{def:subgroups}
Let $(G,*)$ be a group, $H\subseteq G$ is a subgroup of $G$ if it satisfies the following:
\begin{itemize}
    \item $H\neq\varnothing$;
    \item $H$ is closed under $G$ operation: $a,b\in H\Rightarrow a* b\in H$;
    \item $H$ is closed under taking inverses: $a\in H\Rightarrow a^{-1}\in H$.
\end{itemize}
Associativity is inherited from $G$, and the above properties imply the existence of identity element \cite{omn}.
\end{definition}

\begin{definition}[Ring]
    A set $R$ is called a (commutative) \textit{ring} if it has two operations: addition ($+$) and multiplication ($\times$) satisfying the following properties:

\begin{alineas}
    \item $R$ is an abelian group under addition
    \item (multiplicative associativity) $(a\times b)\times c = a\times (b\times c)$, for all $a,~b,~c\in R$ ;
    \item (distributivity) $a\times (b+c)=a\times b + a\times c$ for all $a,~b,~c\in R$;
    \item (multiplicative commutativity) $a\times b=b\times a$ for all $a,~b\in R$;
    \item (multiplicative identity) There exists an element, named unity element and denotedÂ as $1$, such that $1\times a = a\times 1 = a,$ for all $a\in R$.
\end{alineas}

Property d) is not mandatory for general non-commutative rings, but in this text, the term ``ring'' indicates a commutative one. Some examples of rings: $\mathbb{Z}$, ring of integers; $\mathbb{Z}_q$, the integers $\bmod$-$q$ and $\mathbb{Z}[X]$, set of polynomials with integer coefficients. The latter is a special ring that will be the base of our encryption schemes.
\end{definition}

\begin{definition}[Ideal]
    Given a ring $R$, a subset $I\subseteq R$ is called an \textit{ideal} of $R$ if its an additive subgroup of $R$ and satisfies:
$$r\times i \in I\text{ for all } r\in R,~i\in I$$
\end{definition}
Every ideal has a set of generators $G=\{g_1,\ldots,g_n\}$, such that 
$$I=(G)=\Big\{\sum_{i=1}^{n}g_ir_i\mid r_i\in R\Big\}$$
$G$ is called a \textit{basis} of $I$ if its elements are linearly independent. $(G)$ denotes the ideal generated by basis $G$. $I$ is a \textit{principal ideal} if $G$ has just a single element.

Two ideals $I$ and $J$ are called \textit{relatively prime ideals} of a ring $R$ if $I+J=R$, where $I+J=\{i+j\mid i\in I,j\in J\}$.

An example of (principal) ideal of the ring of integers is $(2)=\{2r\mid r\in\mathbb{Z}\}$, so-called even numbers. One can easily verify that it satisfies all the above properties.

\begin{definition}[Fields]
    A Field $F$ is a commutative ring, where for every non-zero element $a\in F$ there exists $a^{-1}\in F$ such that $a\times a^{-1}=1$, being $1$ the ring unity element.

    $\mathbb{Q},\mathbb{R}$ and $\C$ are examples of fields, but $\mathbb{Z}$ is not.
\end{definition}

\section{Homomorphisms and Quotient Rings}\label{sec:homo}
\begin{definition}[Group homomorphism]\cite{omn}
Given two groups $(G,\cdot)$ and $(H,*)$, a group homomorphism $\varphi:G\to H$ is a function that preserves products, i.e.,
$$\varphi(a\cdot b)=\varphi(a)*\varphi(b),~~~\text{ for } a,b\in G$$

Note that the product on left hand side is that of $G$, while the one the right is that of $H$. In future notations, for simplicity, we will use a single notation for representing theese two different products. The context determines which one of them have to be considered, e.g., $x\cdot y$ means $x\cdot y$, if $x,y\in G$, while meaning $x*y$, if $x,y\in H$.
\end{definition}

\begin{definition}[Group isomorphism] Let $\varphi$ be a group homomorphism between the groups $G$ and $H$. We call $\varphi$ a group isomorphism if $\varphi$ is a bijective function, that is, injective and surjective at the same time:
\begin{alineas}
    \item (Injectiveness) $\varphi:G\to H$ is injective if, for $a,b\in G$, $a\neq b$ implies $\varphi(a)\neq\varphi(b)$; 
    \item (Surjectiveness) $\varphi:G\to H$ is surjective if every element of $H$ is mapped, i.e., $\forall h \in H,~\exists g\in G,$ such that $\varphi(g)=h$.
\end{alineas}
    
\end{definition}
\begin{definition}[Ring homomorphism] Let $R$ and $S$ be rings. A map $\varphi:R\to S$ is called a ring homomorphism if it preserves addition/multiplication operations and the unity element:
\begin{align*}
    \varphi(a+b)&=\varphi(a)+\varphi(b)\\
    \varphi(a\times b)&=\varphi(a)\times \varphi(b)\\
    \varphi(1_R)&=1_S
\end{align*}
Note that since $R$ and $S$ are groups under addition, $\varphi$ is also a group homomorphism. Notations $1_R$ and $1_S$ represents, respectively, the unity element from $R$ and the unity element from $S$. $\varphi(0_R)=0_S$ is a consequence of group properties\footnote{Here $0_R$ denotes the identity element of $R$ when viewed as an additive group; Analogously we define $0_S$.} \cite{omn}.
\end{definition}
Some ring homomorphisms examples:
\begin{alineas}
    \item Integer modular reduction operation:
\begin{align*}
    \varphi:\Z&\to\Z_q\\
    \varphi(a)&=a(\bmod~q)
\end{align*}

\item Polynomial evaluation at $a\in R$:
\begin{align*}
    \varphi_a:R[X]&\to R\\
    \varphi_a(p(X))&=p(a),
\end{align*} where $R[X]$ is the set of polynomials with coefficients in a ring $R$, and $p(X)$ is a generic polynomial in $R[X]$.
\end{alineas}
\begin{definition}[Kernel] Let $\varphi:R\to S$ be a ring homomorphism. The kernel of $\varphi$ is the pre image of $0$:
$$\ker \varphi = \{r\in R\mid \varphi(r)=0\}$$
\end{definition}
In the above homomorphism examples, the kernel of modular reduction by $q$ is the set of multiples of $q$. The kernel of polynomial evaluation at $a$ is the set of all polynomials in $p(X)\in R[X]$ such that $a$ is one of its roots, i.e., $p(a)=0$.

\begin{proposition}\label{prop:kernel}
    If $\varphi:R\to S$ is a ring homomorphism, then $\ker\varphi$ is an ideal of $R$. \cite{ring_theory}
\end{proposition}
\begin{proof}
    We have to prove that $\ker\varphi$ is an additive subgroup of $R$ and that it satisfies:
    $$r\times i\in \ker\varphi,\forall r\in R,i\in\ker\varphi,$$
    which means $\varphi(r\times I)=0$. Indeed, that's the case:
    $\varphi(r\times i)=\varphi(r)\times\varphi(i)=\varphi(r)\times0=0.
    $
    Now let's prove the three subgroup axioms (Def. \ref{def:subgroups}) for the addition operation, assuming $\varphi(0)=0$ as a fact.

    \begin{itemize}
        \item $\ker\varphi\neq\varnothing$: 
        Since $\varphi(0)=0$, $\ker\varphi$ has at least $0$ as element;

        \item $\ker\varphi$ is closed under $+$: 
        Take $a,b\in\ker\varphi$. Using this fact and additive homomorphism property, we have $  \varphi(a+b)=\varphi(a)+\varphi(b)=0+0=0\Rightarrow a+b\in\ker\varphi$;

        \item $\ker\varphi$ is closed under (additive) inverse: If $a\in\ker\varphi$, $\varphi(a)=0$, then $0=\varphi(0)=\varphi(a+(-a))=\varphi(a)+\varphi(-a)=\varphi(-a)$. So $\varphi(-a)=0$ impling $-a\in\ker\varphi$
    \end{itemize}
\end{proof}
\begin{definition}[Ring isomorphism]
    A map $\varphi:R\to S$ is called a ring isomorphism if it is a ring homomorphism, and $\varphi$ is a bijective function. In this case, we denote $R\cong S$, for $R$ being isomorphic to $S$.
\end{definition}
A famous example of group isomorphism is the relation between $(\mathbb C,+)$ and $(\mathbb{R}^2,+)$: \begin{align*}\varphi:\C&\to\mathbb{R}^2\\\varphi(a+bi)&=(a,b),\end{align*}
if we define multiplication in $\mathbb{R}^2$ as $(a,b)(c,d)=(ac-bd,ad+bc)$ it become a ring isomorphism.

\begin{definition}[Cosets]
    Let $H$ be a subgroup of an abelian group $(G,\cdot)$. A translation of $H$,
    $$\lambda_g(H)=\{g\cdot h\mid ~h\in H\},$$
    is called a \textit{coset} of $H$, for $g\in G$.
    
    We denote the set of all cosets of $H$ by:
$$G/H\stackrel{\text{def}}{=}\{g\cdot H\mid g\in G\},$$ where $g\cdot H = \{g\cdot h\mid h\in H\}$.
\end{definition}

Since a ring $R$ can be viewed as an additive abelian group and an ideal $I\subseteq R$ as a subgroup. We extend the coset notion to rings as:
$$R/I=\{I+r\mid r\in R\},$$ where $I+r=\{i+r\mid i \in I\}$.

For example: Take the ring of integers $\Z$ and the multiples of three ideal $I=(3)$. The cosets of $I$ are the translations of $I=\{\ldots,-3,0,3,6,\ldots\}$:
\begin{align*}
    0+I&=\{\ldots,-3,0,3,6,\ldots\}\\
    1+I&=\{\ldots,-2,1,4,7,\ldots\}\\
    2+I&=\{\ldots,-1,2,5,8,\ldots\}\\
\end{align*}
Summing other elements of $\Z$ to $I$ will result in one of the above sets. We can give an algebraic structure to these cosets and transform them into rings. 

For each coset, we choose a representative $r$ for $\overline{r}=r+I$, and we can define addition, multiplication and prove the ring axioms for these operations, characterizing the \textit{Quotient Ring} \cite{ring_theory}. When working with a quotient ring in practice, instead of summing two (possibly infinite) cosets, we elect some representatives and operate on them. In the above example, $\Z/(3)=\{\overline{0},\overline{1},\overline{2}\}$, and $\overline{1}+\overline{2}=\overline{3}$, which is the same set as $\overline{0}$. 

A common notation for integers modulo $q$, for example, is $\Z/q\Z$ which is actually the set of cosets of the ideal of multiples of $q$. It's also common to choose the representatives as $\{0,1,\ldots,q-1\}$, but there is nothing stopping us from choosing for example $\Z\cap(-q/2,q/2]$; in this case the representative are centered in $0$ for an odd $q$, e.g., $\Z/3\Z=\{\overline{-1},\overline{0},\overline{1}\}$. That's exactly the choice of representatives we make in Section \ref{sec:ckks}, where the goal is to minimize the size of messages and ciphertext for a better performance of the encryption scheme.

The following theorem is perhaps one of the most important theorems of group and ring theory and provides an alternative way of looking at quotient rings of kernels.
\begin{theorem}[First Ring Homomorphism Theorem] Let $R,S$ be rings, if $\varphi:R\to S$ is a ring homomorphism, and $\varphi(R)$ its image, then $R/\ker\varphi\cong\varphi(R)$. For proof, refer to \cite{ring_theory}.
\end{theorem}

Returning to the example of $\Z/q\Z$, take the modular reduction homomorphism $\varphi(a)=a~(\bmod q)$, its kernel is the ideal $q\Z$ of multiples of $q$. What the above theorem is saying is that the image $\varphi(\Z)=\Z~(\bmod{q})=\{0,1,2\}$ is isomorphic to the quotient ring $\Z/q\Z$.

Let $\Z[X]$ be the polynomials with integer coefficients and $f(x)= x^n+1$, a monic polynomial\footnote{A monic polynomial is a polynomial which the coefficient of the highest degree variable is $1$.} with degree $n$. Define the homomorphism $\varphi:\Z[X]\to\Z[X]$, that take a polynomial $p(x)\in\Z[X]$ and returns $r(x)$, the remainder of the polynomial division $p(x)/f(x)$, using grade-school division algorithm. $\ker\varphi $ is the set of polynomials with remainder equal $0$, i.e., the set of multiples of $x^n+1$ in $\Z[X]$, which is the ideal generated by $f$ (Prop. \ref{prop:kernel}). The Homomorphism Theorem affirms that $\Z[X]/(f(x))\cong\varphi(\Z[X])$, so we can represent the set of cosets of $(x^n+1)$ simply as the image of $\varphi$: the set of remainders in the division by $f(x)$, which can be viewed as the integer polynomials with degree less than $n$. This will be a central ring in the encryption schemes we shall further define.

\section{Cyclotomic polynomials}\label{sec:cyc}

In this section, we define and review some properties of cyclotomic polynomials, which will play a central role in the homomorphic cryptography setup.

\begin{definition}[Roots of unity] The $n^{th}$ roots of unity are the solution set of the equation $x^n-1=0$ in the field of complex number $\mathbb C$:
$$\sqrt[n]1=\{\zeta_n^k;k=0,1,\ldots,n-1\},$$
where\footnote{In Euler's notation $\exp{(i\theta)}=\cos\theta+i\cdot\sin\theta$} $\zeta_n=\exp{(2\pi i/n)}$
\end{definition}
In the complex plane, these roots are distributed over the unitary circumference and equally separated by an angle of $2\pi/n$. Figure \ref{fig:roots_of_unity} show the example of the $8^{th}$ roots of the unity.

\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.4]{files/figures/roots_of_unity.png}
    \caption{$8^{th}$ roots of unity}
    \label{fig:roots_of_unity}
\end{figure}

\begin{definition}[Primitive roots of unity]\cite{brilliant}\label{def:prim_roots}
The $n^{th}$ primitive roots of unity are:
$$\{\zeta \in \mathbb C;\zeta^n=1\text{ and }\zeta^k\neq1,\forall ~ k<n \},$$
for positive integers $k$. They are the subset of $n^{th}$ roots of unity which are not $k^{th}$ roots of unity, for all $k<n$. They can be alternatively defined as:
$$\{\zeta_n^k;1\leq k \leq n,\gcd(k,n)=1\},$$ where $\gcd(k,n)$ is the greatest common divisor of $k$ and $n$.
\end{definition}
From the Figure \ref{fig:roots_of_unity} example, the $8^{th}$ primitive roots of unity are $\zeta_8,\zeta_8^3,\zeta_8^5,\zeta_8^7$.
% Indeed, $\zeta_n^k=\exp(2k\pi i/n)$ will be equal to $1$ if, and only if the exponent is an integer multiple of $2\pi i$, which is not the case when $\gcd(k,n)=1$, since $k/n$
% tmp\cite{brilliant}

\begin{definition}[Cyclotomic polynomial] \label{def:cyclo}The \textit{$n$-th cyclotomical polynomial} is defined as:
\begin{align*}
    \Phi_n(x) = \prod_{\substack{1\leq k \leq n\\ \gcd(k,n)=1}}^{n}(x-\zeta_n^k)
\end{align*}
\end{definition}

Notice that its roots are the $n^{th}$ primitive roots of unity.

Using the definition, we can derive some cyclotomical polynomials, for example $\Phi_1(x)=x-1$ trivially, and $\Phi_2(x)=x+1$, since from the $2^{nd}$ roots of unity $-1$ and $+1$, only $-1$ are primitive ones.

The $3^{rd}$ primitive roots of are $\zeta_3^1$ and $\zeta_3^2=\overline{\zeta_3^1}$, then:
\begin{align}
    \Phi_3(x)&=(x-\zeta_3^1)(x-\zeta_3^2)\nonumber\\
    &=x^2-x(\zeta_3^1+\zeta_3^2)+\zeta_3^1\zeta_3^2\nonumber\\
    &=x^2-x(\zeta_3^1+\overline{\zeta_3^1})+e^{2\pi i(1+2)/3}\label{eq:zeta3}\nonumber\\
    &=x^2-x(2\cdot\cos(2\pi/3))+e^{2\pi i}\\
    &=x^2+x\left(2\cdot \frac12\right)+1\nonumber\\
    &=x^2+x+1\nonumber
\end{align}

The equality (1) holds due to the sum of complex conjugates being equal to two times the real part since we cancel out the imaginary terms.

\begin{theorem} \label{teoremaco}For all positive integers $n$ we have\footnote{Here, $d|n$ denotes ``$d$ divides $n$'', so the product ranges over $d$, where $d$ is a divisor of $n$.}:
$$\displaystyle x^n-1=\prod_{d|n}\Phi_d(x)$$ 
\end{theorem}

The above theorem provides a analytical formula to recursively generate the cyclotomic polynomials:
$$\displaystyle\Phi_n(x)=\dfrac{x^n-1}{\displaystyle\prod_{\substack{d|n\\d\neq n}}\Phi_d(x)}$$

We can use it to derive simpler, and non-recursive expressions for particular cases of interest:

\begin{corollary}[Prime Cyclotomical Polynomial]
If $p$ is a prime number, then:
$$\Phi_p(x)=x^{p-1}+x^{p-2}+\ldots+x+1$$
\end{corollary}

\begin{proof}
By the previous theorem, and the fact that the only $d<p$ satisfying $d|n$ is $d=1$:

$$\Phi_p(x)=\dfrac{x^p-1}{\displaystyle\prod_{\substack{d|p\\d\neq p}}\Phi_d(x)}=\dfrac{x^p-1}{\Phi_1(x)}=\dfrac{x^p-1}{x-1}$$

The polynomial division algorithm concludes that such a division actually results in what is claimed in the corollary.

An easy way to assert it, is by multiplying the divisor $x-1$ by $\displaystyle\sum_{i=0}^{p-1}x^i$ and checking if it is equal to $x^p-1$:
\begin{align*}
    (x-1)\left(\sum_{i=0}^{p-1}x^i\right)&=\sum_{i=0}^{p-1}x^{i+1}-\sum_{i=0}^{p-1}x^i\\
    &=\sum_{i=0}^{p-1}x^{i+1}-x^{i}\\
    &=x^{(p-1)+1}-x^{0}\\
    &=x^{p}-1
\end{align*}
\end{proof}
The following formula will be crucial to instantiate plaintext and ciphertext spaces in the encryption schemes.
\begin{corollary}[Power of Two Cyclotomic Polynomial]
If $M=2^n$, for a given positive integer $n$, then:
$$\Phi_M(x)=x^{M/2}+1$$
\end{corollary}
\begin{proof}
We'll proceed by strong induction in $n$ \cite{herstein1996abstract},  proving an equivalent statement\footnote{One can easily verify that $\dfrac{x^{M}-1}{x^{M/2}-1} = x^{M/2}+1$ using the polynomial division algorithm for example, or multiplying the divisor with the quotient}: 
\begin{equation}
\label{eq:phim}
    \Phi_{M_n}(x) = \dfrac{x^{M_n}-1}{x^{M_n/2}-1}
\end{equation}
We're denoting $2^n$ by $M_n$ to have a cleaner notation of nested exponents; hence $M_n/2=M_{n-1}$.

(Base case) For $n=1$, $\Phi_{M_1}(x)=\Phi(2)=x+1$, as we derived before. This is the LHS of \ref{eq:phim}. The RHS is $\frac{x^2-1}{x-1}=\frac{(x+1)(x-1)}{x-1}=x+1$, so the formula is valid in this case.

(Inductive Hypothesis) Assume that \ref{eq:phim} hold for $M_k$ for all $k<n$ positive integers.

(Inductive Step) Let's deduce that it also holds for $M_n$: By Theorem  \ref{teoremaco}, we have:
\begin{align*}
    \Phi_{M_n}(x) &= \dfrac{x^{M_n}-1}{\displaystyle\prod_{\substack{d|M_n\\d\neq M_n}}\Phi_d(x)}
\end{align*}
Notice that $\{d\in\mathbb{Z}^+;d|M_n\} = \{M_0,M_1,\ldots,M_{n-1}\}$, i.e., the divisors of $M_n$ are the powers of two with exponent less than $n$. Then our expression becomes:
$$\Phi_n(x) = \dfrac{x^{M_n}-1}{\Phi_{M_0}\Phi_{M_1}\ldots\Phi_{M_{n-1}}}$$
Using $\Phi_{M_0}(x)=x-1$ and the inductive hypothesis, we can rewrite the denominator as:
\begin{align*}\Phi_{M_0}\Phi_{M_1}\ldots\Phi_{M_{n-1}}&=(x-1)\cdot \dfrac{x^{M_1}-1}{x^{M_0}-1}\cdot\dfrac{x^{M_2}-1}{x^{M_{1}}-1}\ldots\cdot\dfrac{x^{M_{n-1}}-1}{x^{M_{n-2}}-1}\\&=x^{M_{n-1}}-1,\end{align*}
since that's the only term left after canceling out left numerators with right denominators. We then conclude:
\begin{align*}
    \Phi_{M_n}(x) &= \dfrac{x^{M_n}-1}{x^{M_{n-1}}-1}=x^{M_n/2}+1
\end{align*}
\end{proof}

Another interesting property of cyclotomic polynomials, is the following theorem:
\begin{theorem}
For any positive integer $n$ we have $\Phi_n(x)\in\Z[x]$, That is, $\Phi_n(x)$ is a polynomial
with integer coefficients.\cite{sun2013cyclotomic}
\end{theorem}
We defined these polynomials as products of several complex numbers, but the coefficients end up in the integers! Such a beautiful property, together with the fact the cyclotomic polynomials are monic \cite{sun2013cyclotomic}, will allow us to determine later quotient rings like $\Z[x]/(\Phi_n(x))$ to our encryption context.

\section{Lattices}\label{sec:lattices}

This section introduces lattices and hard lattice problems that will base the security of fully homomorphic schemes.
\begin{definition}[Lattice]
Let $b_1,\ldots,b_k\in\mathbb{R}^n$ be linearly independent vectors, then
$$\mathcal{L}=\Big\{\sum_{i=1}^ky_ib_i\left|\right.y_i\in\mathbb{Z}\Big\}$$
is a ($n$-dimensional) \textbf{lattice} and $(b_1,\ldots,b_k)$ its \textbf{basis}. If we create a $n\times k$ matrix $\mathbf B$, where the $i$-th column is $b_i$, then we can write
$$\mathcal{L}(\mathbf B)=\{\mathbf B y\mid  ~y\in \mathbb{Z}^k\}\subset \operatorname{span}(B)$$
\end{definition}
Figure \ref{fig:lattices} shows two geometrical examples in $\R^2$, the first one using canonical basis $(e_1,e_2)$, and the second using $B=(b_1,b_2)$, with $b_1=e_1$ and $b_2=\frac{1}{\sqrt2}(2,1)$
\begin{figure}[!htb]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=0.25]{files/figures/lattice_canonical.png}
  \caption{Canonical basis}
  \label{fig:canonical_lattice}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=0.25]{files/figures/lattice2.png}
  \caption{Basis $B=(b_1,b_2)$}
  \label{fig:sub2}
\end{subfigure}
\caption{Lattices examples}
\label{fig:lattices}
\end{figure}

\begin{definition}[Ideal lattice]
An \textbf{ideal lattice} $\mathcal L$ is a lattice that is closed under addition and multiplication: For $v_1,v_2\in \mathcal{L}$, we have $v_1+v_2\in \mathcal{L}$ and $v_1\cdot v_2\in\mathcal L$, with the operations inherited from $\R^n$.
\end{definition} 

\begin{definition}[Successive minima]
Given a norm $||\cdot||$, the $i^{th}$ successive minima of an $n$-dimensional lattice $\mathcal L$, denoted by $\lambda_i(\mathcal L)$ is the smallest $r$ such that the origin-centered ball with radius $r$ (the set $\{x\in\mathbb{R}^n\mid||x||\leq r\}$) contains $i$ linearly independent (LI) lattice vectors.
\end{definition}

Considering the euclidian norm $||(x_1,x_2)||_2=\sqrt{x_1^2+x_2^2}$, in Figure \ref{fig:canonical_lattice}, for example, we have  $\lambda_1(\mathcal L)=\lambda_2(\mathcal L)=1$, since the unity ball contains the two LI canonical vectors. However, in Figure \ref{fig:sub2}, it is not so obvious, but $\lambda_1(\mathcal L)=||b_3||_2\approx 0.82$, where $b_3=b_2-b_1$ and $\lambda_2(\mathcal L) = ||b_4||_2\approx0.92$, with $b_4=b_3-b_1$. In Figure \ref{fig:successive_minimas}, we can visually verify that $b_3$ and $b_4$ are LI.

\begin{figure}[!htb]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=0.25]{files/figures/lambda1.png}
  \caption{First successive minima}
  \label{fig:lambda1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=0.23]{files/figures/lambda2.png}
  \caption{Second successive minima}
  \label{fig:lambda2}
\end{subfigure}
\caption{Successive Minimas}
\label{fig:successive_minimas}
\end{figure}

\subsection{Lattice Problems}
Now, we can define two famous lattice problems, all considered NP-hard \cite{hardnes}.

\begin{definition}[Shortest Vector Problem - SVP]\label{def:svp} Given a lattice $\mathcal L$, a norm $||.||$, and an approximation factor $\gamma$, find a non-zero $v\in\mathcal L$ such that $||v||\leq\gamma \lambda_1(\mathcal L)$, i.e., the non-zero lattice vector closest to the origin. 

``The approximation factor $\gamma$ is usually taken as a function of lattice dimension $\gamma(n)$.'' \cite{ppt_dm}.
\end{definition}

In the above example of $\mathcal L (b_1,b_2)$, the shortest vector is $b_3$, for $\gamma=1$.

\begin{definition}[Shortest Independent Vector Problem - SIVP] Given a lattice $\mathcal L$ of dimension $n$ and a norm $||.||$, find $n$ linearly independent vectors $v_1,v_2,\ldots,v_n$ such that $\displaystyle\max_{i}{||v_i||}\leq\gamma\lambda_n(\mathcal L)$.
\end{definition}

For $\mathcal L (b_1,b_2)$, the solution for the SIVP with $\gamma=1$ with $\gamma=1$ is $\{b_3,b_4\}$.

These problems establish the so-called \textit{lattice-based cryptography}, which are cryptosystems that have their security based on solving the above problems or its variants. All The fully homomorphic encryption schemes we shall dive deeper into in the next chapter are lattice-based.

\subsection{Ring Learning with Errors}
Now that we have computationally complex challenges, the next step is, based on these results, to construct a concrete secure cryptography scheme. The following two problems are a step in this direction.

\begin{definition}[Learning with Errors - LWE] Given an integer $n$, a prime integer $q$ such that\footnote{$\poly(n)$ denotes a polynomial function of $n$.} $2\leq q\leq \poly(n)$ and a distribution $\chi$ over $\Z_q$. Fix $\bds\in \Z_q^n$, the Search $\operatorname{LWE}_{n,q,\chi}$ problem is to recover $\boldsymbol s$, given observations $(\bda_i,b_i)$, where\footnote{Notation $x\xlongleftarrow[]{\chi}S$ means $x$ was drawn from distribution $\chi$ over the set $S$, and $\mathcal{U}$ is the uniform distribution}:
\begin{align*}
    \bda_i&\xlongleftarrow[]{\mathcal U}\Z_q^n\\
    b_i &= \langle \bda_i,\bds\rangle + e_i~(\bmod q)\\
    e_i&\xlongleftarrow[]{\chi}\Z_q
\end{align*}
\end{definition}
The Decision $\operatorname{LWE}_{n,q,\chi}$ is the problem of distinguishing between the distribution of $(\bda_i,b_i)$ gotten from the above procedure and the uniform distribution over $\Z_q^{n+1}$.

Under reasonable assumptions on $\chi$, if an algorithm efficiently solves the above (decision) problem, GapSVP and SIVP can also be solved efficiently \cite{regev09}. 

LWE provides a nice setup for private key encryption since one can expose $(\bda_i,b_i)$ while the hardness of lattice-based problems guarantees the security of $\bds$. Further, we shall name $(\bda_i,b_i)$ the public key and $\bds$ the private key. One can still prove that Search-LWE can be reduced to Decision-LWE \cite{lyubashevsky10}, which completes the cycle.

In our main FHE construction, a variant of LWE bases the scheme:
%% parei aqui
\begin{definition}
[Ring Learning with Errors - RLWE]\label{def:rlwe} Set integers $n,q$, with $n$ being a power of two, and $2\leq q \leq \poly(n)$. Let $f(x)=x^n+1$ (the $2n$-th cyclotomic polynomial), define $\mathcal R=\Z[X]/( f(X))$, a distribution $\chi$ over $\mathcal R$ and $\mathcal{R}_q=\mathcal R/(q) =\Z_q[X]/(f(X))$ which can be represented by polynomials with integer coefficients wrapped by $q$ and with degree up to $n-1$.

Let $s=s(x)\in \mathcal{R}_q$ be an element chosen uniformly from the ring. The Search $\operatorname{RLWE}_{n,q,\chi}$ problem is to recover $s$ given a set of pairs $(a_i,b_i)\in \mathcal{R}_q^2$, with
\begin{align*}
    a_i&\xlongleftarrow[]{\mathcal U}\mathcal{R}_q\\
    b_i &= a_i\cdot s + e_i~(\bmod q)\\
    e_i&\xlongleftarrow[]{\chi}\mathcal R
\end{align*}
Analogously with LWE, we define Decision $\operatorname{RLWE}_{n,q,\chi}$ as the problem of distinguishing the distribution of the above pairs from a uniform distribution over $\mathcal{R}_q^2$. 
\end{definition}
% An observation in both LWE and RLWE is that, in practice, the distribution $\chi$ of $e_i$ must yield small enough errors compared to $q$. That's why we omit $\bmod q$ after the equation of $b_i$'s. Such a thing would guarantee that $b_i$ is an element of $\Z_q$ or $\mathcal{R}_q$.
The Search RLWE can also be reduced to Decision RLWE. Moreover, under some assumptions over the parameters $n,q,\chi$, which we won't state here, an efficient algorithm for Decision $\operatorname{RLWE}_{n,q,\chi}$ implies an efficient algorithm for solving SVP \cite{lyubashevsky10}.

The choice of $f(x)$ being a power of two cyclotomic polynomial is purely technical; in general, $f(x)$ could be any cyclotomic polynomial, and all the theory would still holds. We shall further want to multiply two instances of the cyclotomic ring, and there is a method based on Fast Fourier Transform to perform such task \cite{fftmult}. But choosing specifically $f(x)=x^n+1$ admits optimized and faster implementations \cite{swifft}.


\chapter{Fully Homomorphic Encryption}\label{ch:fhe}
This chapter gives an overview of the FHE research. Section \ref{sec:privhom} returns in 1978 and revises the original proposal of the existence of FHE schemes \cite{Rivest1978}, which was called \textit{privacy homomorphisms}. Section \ref{sec:gentry} explores Gentry's solution through his Ph.D. thesis \cite{gentry2009fully} proving such existence. Section \ref{sec:ckks} presents the so-called CKKS scheme \cite{ckks17}, a practical and modern scheme that allows approximate encryption of complex (so, also real) numbers, well suitable for machine learning applications. 

\section{Privacy Homomorphisms}
\label{sec:privhom}
Assume we can represent the unencrypted data by an algebraic structure $\mathcal P= (S;f_1,\ldots,f_k)$, i.e., a set $S$ ported with the operations $f_1,\ldots,f_k$. We will further call this structure the plaintext space.

An alternative algebraic structure, the ciphertext space $\cipher=(S',f'_1,\ldots,f'_k)$, is constructed to represent the encrypted data. To build a \textit{privacy homomorphism} \cite{Rivest1978},  one needs a decryption function $\phi:S'\to S$ and its inverse $\phi^{-1}:S\to S'$ satisfying the homomorphic property from $\cipher$ do $\Plain$:
\begin{align}
    \label{privhom}
    f'_i(a,b,\ldots)&=c\Rightarrow\nonumber\\ f_i(\phi(a),\phi(b),\ldots)&=\phi(c),\text{ for } i=1,\ldots,k\\
    \text{with }a,b,&\ldots\in S'\nonumber
\end{align}
This means that for all available operations $f'_i$, its evaluation on encrypted elements must result in a value that, after decryption, corresponds to the same computation on the unencrypted domain.

An example of privacy homomorphism is the RSA cryptosystem \cite{rsa}, which uses $\Plain = (\Z_p;\times_p)$, the integers modulo $p$ with $p$ prime, and the multiplication modulo $p$. Setting $N=pq$, where $q$ is a large prime and choosing $e$ coprime with $(p-1)(q-1)$,  the ciphertext space as $(\Z_N;\times_N)$ and is connected with $\Plain$ through the encryption function:
\begin{align*}
    \phi^{-1}&:\Z_p\to\Z_N\\
    \phi^{-1}(x)&=x^e(\bmod N)
\end{align*}
Taking $x,y\in\Z_p$ and its encrypted versions $x'=\phi^{-1}(x),~y'=\phi^{-1}(y)$, we have:
\begin{align*}
    x'\times_N y'&= (x^e)(y^e)(\bmod N)\\
    &=(xy)^e(\bmod N),
\end{align*}
which is an encryption of $xy$. Then the multiplication satisfies property \ref{privhom}, showing that such a system is indeed a privacy homomorphism.

\subsection{Requirements and Limitations}\label{subsec:reqs}
The following properties for $\cipher,\phi$ and $\phi^{-1}$ are required by the authors:
\begin{alineas}
    \item for a given element $s\in S$, its encrypted version $\phi^{-1}(s)$ should not require much more storage space;
    \item $\phi$ and $\phi^{-1}$ should be easy to compute;
    \item the operations $f_i'$ should be efficiently computable in $\cipher$;
    \item $\phi$ should not be vulnerable to the chosen plaintext attack;
    \item The operations of $\cipher$ should not be sufficient to yield an efficient computation of $\phi$.
\end{alineas}

The last requirement forces a critical restriction on such morphisms: a comparison operator ``$\leq$'' can't be available in the ciphertext space, otherwise, no secure privacy homomorphism exists.

Take for example $\Plain = (\N;+,\leq)$ and $\cipher = (W;+',\leq')$ for some $W$. A malicious party who has $\phi^{-1}(n)$ and wants to discover what $n\in\N$ generated such ciphertext can apply the following binary search strategy:
\begin{alineas}
\item compute $1'=\phi^{-1}(1)$;
\item compute $2'=1'+'1'$, then $4'=2'+'2'$;
\item continue until finding $k$, such that $\phi^{-1}(n)\leq'(2^k)'=\phi^{-1}(2^k)$
\item knowing that $n\in[2^{k-1},2^{k}]$, compute an encryption of the interval midpoint $\phi^{-1}(m)=\phi^{-1}(2^{k-1}-2^{k-2})$;
\item homomorphically compare $\phi^{-1}(n)\leq'\phi^{-1}(2^{k-1})+'\phi^{-1}(m)$;
\item repeat the last two steps properly redefining the interval until getting $n$ exactly.
\end{alineas}
This is an efficient $O(\log n)$ algorithm to compute the decryption function $\phi$, using the operations in $\cipher$ and the ability to generate encryptions of arbitrary constants (such as $1$ and $m$ in the above example).

The article finishes with the authors pondering if such an approach with all required security restrictions could be worthwhile in practice and what algebraic structures $\Plain$ would provide useful privacy homomorphisms.
% \section{First Generation Fully Homomorphic schemes}
% \begin{alineas}
% \item somewhat/fully homomorphic
% \item bootstrapping
% \item integer scheme
% \item caveats and implementation paper
% \end{alineas}

\section{Bootstrappable encryption}
\label{sec:gentry}
The existence of (useful) privacy homomorphisms remained an open problem for more than 30 years until \cite{gentry2009fully} came up with a beautiful solution in his Ph.D. thesis. He introduced a privacy homomorphism based on ideal lattices and proposed a method named bootstrapping, his most significant insight, to control ciphertext noise growth. A second paper was proposed, with a slightly simpler scheme using integers instead of lattices \cite{fhe_integers}.

This section summarizes Gentry's achievement, \ref{sub:over} with a complete summarized overview of the solution,  \ref{sub:over} describing the scheme over the integer.
% , and \ref{sub:practical} commenting about practical considerations. 
We let the explanation of the original cryptosystem over ideal lattices to Appendix \ref{appendixA} since not reading doesn't interfere in the text flow.

\subsection{Overview and Bootstrapping}
\label{sub:over}
Let's denote $\phi^{-1}(.)$ by $\enc(\pk,.)$, now requiring a public key $\pk$, and $\phi(.)$ by $\dec(\sk,.)$, where $\sk$ is a secret key. The construction also requires an evaluate algorithm $\eval(\pk;.)$ that computes a function $f$ in the ciphertext space. In the previous section's construction, this algorithm $\eval(\pk,f_i,\ldots)=f'_i(\ldots)$, i.e., the computation of $f$ in the encrypted domain won't be a direct evaluation, but a modified one, adapting to restrictions and patterns of the new space.

Take a function $f\in\mathcal P$ in the plaintext space, and some elements $s_1,s_2,\ldots\in S$, and its encrypted versions $c_i=\enc(\pk,s_i)$. Rewriting \ref{privhom} in this new notation, we get the correctness property for $f$:
\begin{align}
\label{eq:correctness}
    \dec(\sk,\eval(\pk,f,c_1,c_2,\ldots))=f(s_1,s_2,\ldots)
\end{align}
The encryption function \textbf{must add random noise to the plaintext} messages to resist the chosen ciphertext attack as required in the property (d) of \ref{subsec:reqs}. Calling $\enc(\pk,s)$ multiple times would yield different ciphertexts each time, but decrypting all of them, returns to $s$.

\begin{definition}[Fully Homomorphic Encryption - FHE]
The first definition of FHE scheme defines it as a scheme that allows anyone to evaluate ``any desired function $f$'' over the encrypted data $c_1,c_2,\ldots$ without decrypting it, just as privacy homomorphisms. \cite{gentry2009fully}
\end{definition}
In practice, what is proven is the existence of a scheme that can evaluate addition and multiplication functions, which are enough to compose any boolean circuit.
\begin{align*}
    \dec(\sk,\eval(\pk,+,c_1,c_2))=s_1+s_2\\
    \dec(\sk,\eval(\pk,\times,c_1,c_2))=s_1\times s_2\\
\end{align*}
Because of the noise added in the encryption step, if we perform multiple additions and multiplications, the noise can grow at levels that might affect the above correctness property (this will soon become clearer). Then, we introduce the following concept:
\begin{definition}[Somewhat Homomorphic Encryption - SHE] Let $F$ be a circuit of composition of additions and multiplications with a given depth. A SHE scheme satisfies the following:
$$\dec(\sk,\eval(\pk,F,c_1,c_2,\ldots))=f(s_1,s_2,\ldots)
$$
only if the depth of $F$ is less than the scheme's maximum allowed depth.
\end{definition}

The bottleneck to achieving an FHE scheme is the introduction of noise in the encryption function. A circuit $F$ with a big enough number of multiplications, for example, might not satisfy the correctness property because of the noise's size compared to the original message.

Then a process called \textit{bootstrap} (or recrypt) is introduced \cite{gentry2009fully}, which is a way of reducing the ciphertext noise by homomorphically evaluating the own scheme decryption function, producing a new ciphertext that encrypts the same message with less noise. 

To achieve a fully homomorphic scheme out of a somewhat homomorphic one, it's enough to prove that the scheme is ``bootstrappable'', i.e., that it can correctly evaluate circuits that are deeper than its own decryption circuit. 

Suppose $c$ encrypts $s$ under $\pk_1$, and we want to reduce its noise; one way to do that is to decrypt $c$ using the secret key, getting back to the plaintext space (without any noise) and then encrypt $s$ again generating a fresh and new encryption. To maintain security and not reveal the actual message, the process is done homomorphically. 

Suppose we have $\sk^* = \operatorname{Encrypt}(\sk_1,\pk_2)$, an encryption of the secret key under a second public key $\pk_2$. Define the $\operatorname{Recrypt}$ algorithm as:
\begin{align*}
   \operatorname{Recrypt}(\pk_2,\sk^*,\dec,c)&\\
   \text{Set }c^*&=\enc(c,\pk_2)\\
   \text{Output }c_2&=\eval(\pk_2,\dec,\sk^*,c^*)
\end{align*}
% The output of Recrypt is encryption of $\dec(\sk_1,c)=s$ under $pk_2$.
Figure \ref{fig:bootstrapping} illustrates this procedure through the blue arrows.

The $\enc$ function might introduce some noise to $c_2$, but as long as this noise is less than the one associated with $c$, we succeed in refreshing ciphertext noise. 

% https://q.uiver.app/?q=WzAsNCxbMCwyLCJjIl0sWzAsMCwiY14qIl0sWzMsMiwibSJdLFszLDAsImNfMiJdLFswLDEsIlxcb3BlcmF0b3JuYW1le0VuY30oXFxvcGVyYXRvcm5hbWV7cGt9XzIsXFxjZG90KSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDIsIlxcb3BlcmF0b3JuYW1le0RlY30oXFxvcGVyYXRvcm5hbWV7c2t9LFxcY2RvdCkiLDJdLFsxLDMsIlxcb3BlcmF0b3JuYW1le0V2YWx9KFxcb3BlcmF0b3JuYW1le3BrfV8yLFxcb3BlcmF0b3JuYW1le0RlY30sXFxvcGVyYXRvcm5hbWV7c2t9XiosXFxjZG90KSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFszLDIsIlxcb3BlcmF0b3JuYW1le0RlY30oXFxvcGVyYXRvcm5hbWV7c2t9LFxcY2RvdCkiXV0=
\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.9]{files/figures/bootstrapping.png}
    \caption{Bootstrapping procedure}
    \label{fig:bootstrapping}
\end{figure}

The SHE schemes proposed by Gentry were not originally bootstrappable because the decryption was too deep. The work then dedicates a lot of effort to minimize the depth of the decryption circuit, but the ability to bootstrap is only achieved by a technique called \textit{squashing}, where the encrypter starts the decryption process, giving partial hints to the decryptor. Although he could arrive at an FHE scheme, squashing introduced additional security requirements.

\subsection{An integer scheme}
\label{sub:int}
A second work from Gentry \cite{fhe_integers} introduces a conceptually simpler SHE scheme using the ring of integers as the underlying algebraic structure instead of ideal lattices. 

We start with a private key scheme and then transform it into a public key one:

\begin{itemize}
    \item $\operatorname{KeyGen}$ - sets the private key as an odd integer $p$
    \item $\enc(p,m)$ - given a bit message $m\in\{0,1\}$, outputs $c=pq+2r+m$, where $q$ and $r$ are choosen randomly in some prescribed interval.
    \item $\dec(p,c)$ - outputs $(c\bmod p)\bmod 2$
\end{itemize}

Correctness property can be easily checked, assuming $2r<p/2$:
\begin{align*}
    &\dec(p,\enc(p,m))\\
    &=\dec(p,pq+2r+m)\\
    &=((pq+2r+m)\bmod p)\bmod 2\\
    &=(2r+m)\bmod 2\\
    &=m
\end{align*}

Let's emphasize the need for bootstrapping with a toy example.

Let's say we want to add $m=1$ continuously. Set $p=29$, and let's suppose the encryption algorithm sampled $q=8, r=3$. Now, take the ciphertext $pq+2r+m$ and add-t to itself $c+c = p(2q)+4r+m+m$.

In the decryption function, the modulo-p reduction will eliminate $p(2q)$, and mod 2 will output us $m+m = 0$ as desired.

In general, if $\alpha\geq 1$ is an integer., $\alpha c=p(\alpha q)+2\alpha r+\alpha m,$

If we want to discover how many times we can add $c$ to itself and the decryption still works, the only condition is $2\alpha r<p$. Solving the inequality for $p=29,r=3$ we get $\alpha<29/6\approx 4.83$. So for $\alpha = 5$ we have no guarantee that the scheme will work.

Since $\alpha = 5$ is odd $\alpha m = 1$, so we would like $\dec(29,5c)=1$, but:
\begin{align*}
    &~~~\dec(29,5c)\\
    &=\dec(29,29\cdot(5 q)+2\cdot5 r+5 m)\\
    & = ((29\cdot(5 q)+30+5 m)\bmod 29)\bmod 2\\
    &=(1+5m)\bmod2\\
    & = 6\bmod 2\\
    & = 0
\end{align*}

Then decryption failed because the error was sum up to $5\alpha r$ and eventually got bigger than $p$.

To obtain a public key encryption scheme out of the above private key one, we set:

$\pk = (x_1,\ldots,x_\tau),\text{ where }x_i=pq_i+2r_i$, $p$ is a given private key, and $q_i,r_i$ are random sampled for each generation of $x_i$.

Then the encryption algorithm is transformed:

\begin{itemize}
    \item $\enc(\pk,m)$ - random sample $S$ from $\{1,\ldots,\tau\}$ and an integer $r$, then output $c = m + 2r + 2\sum_{i\in S}x_i$
\end{itemize}

The security of the scheme is based on the hardness of the \textit{approximate gcd problem}, i.e, find $p$ given its ``approximate multiples'' $x_1,\ldots,x_\tau$.

% \section{Gentry's work}


% \subsection{BFV and BGV schemes (integers)}

% \begin{alineas}
% \item describe BFV primitives (codec/ring)
% \item encrypt/decrypt
% \item relinelization
% \item BGV differences
% \end{alineas}
\subsection{Practical considerations and further research}
\label{sub:practical}
An implementation of Gentry's scheme (using ideal lattices) was proposed in \cite{gentry_implementation}. They used a powerful cloud machine to benchmark the system: 64-bit quad-core Intel Xeon E5450 processor, 3GHz, with 24GB of RAM.

Using $n=2^{15}$ as the lattice dimension (see Appendix \ref{appendixA}), a parameter that provides a high level of security, the scheme took $2.2$ hours for $\operatorname{KeyGen}$ and $31$ minutes for $\operatorname{Recrypt}$. The real bottleneck is the Recrypt algorithm since Keygen is executed only one time, but we need to bootstrap many times for evaluating deep functions, such as iterative algorithms for machine learning optimization. Although Gentry's work was a big mathematical breakthrough, making a practical FHE scheme remained an open problem. 

The research community has focused on achieving computationally practical schemes ever since. In the decade after 2009, a lot of solutions came up with real improvements over the original construction. A standardization was proposed \cite{standards} to discuss security, implementation API, and applications, listing some important schemes such as BFV \cite{bfv12}, BGV \cite{bgv}, and GSW \cite{gsw}.  We will present the CKKS/HEAAN\footnote{HEAAN is the initials of the paper title "Homomorphic Encryption for Arithmetic of Approximate Numbers".\\CKKS stands for the author's surname initials: Jung H. Cheon, Andrey Kim, Miran Kim, and Yongsoo Song } scheme \cite{ckks17}, which is considered the most appropriate for machine learning applications since it has a native solution for supporting complex numbers (so, also real), while previous schemes used boolean or integer based encoding. Although it's not listed on 2018 standards, the scheme is a candidate for future versions of the document.

\section{FHE over the complex numbers}
\label{sec:ckks}
% - brief description about fixed point arithmetic? no 
% - the complex map 
% - give a broad overview and then in subsection describe codec and bootstrapping
The message $m$ of the HEAAN scheme will live in the plaintext of the cyclotomic ring $\mathcal{R}_{q}=\Z_q[X]/(X^N+1)$ with $N$ being a power of two; the ciphertext will be tuples in $\mathcal{R}_q\times \mathcal{R}_q$. This can be quite contradicting to the proposal of the scheme for supporting complex numbers, but this can be reached using a clever encoding/decoding procedure that can map a complex vector $\boldsymbol z\in \mathbb C^{N/2}$ to a polynomial $m\in \mathcal{R}_q$, and vice-versa. This allows us to perform operations in a SIMD\footnote{Single instruction, multiple data}, saving computational costs. Figure \ref{fig:ckks_overview} outlines the process of how CKKS computes a function over a complex vector.
\begin{figure}[!htb]
    \centering
    \includegraphics[]{files/figures/ckks_overview.png}
    \caption{CKKS scheme overview. Adapted \cite{openmined}}
    \label{fig:ckks_overview}
\end{figure}

HEAAN is an approximate scheme that doesn't satisfy the identity correctness property, $\dec(\sk,\enc(\pk,m))=m$. Instead, one will get $\dec(\sk,\enc(\pk,m))=m+e$, and we can guarantee that $e$ is small enough compared to $m$ so that we recover an approximate decryption of the original message. 
% https://q.uiver.app/?q=WzAsNixbMCwwLCJcXGJvbGRzeW1ib2x7en1cXFxcIFxcaW5cXG1hdGhiYiBDXntOLzJ9Il0sWzIsMCwibShYKVxcXFwgXFxpbiBcXG1hdGhjYWwgUl9xIl0sWzQsMCwiYz0oY18xKFgpLGNfMihYKSlcXFxcIFxcaW5cXG1hdGhjYWwgUl9xXjIiXSxbNCwzLCJjJz0gXFxvcGVyYXRvcm5hbWV7RXZhbH0oZixjKVxcXFwgXFxpblxcbWF0aGNhbHtSfV9xXjIiXSxbMiwzLCJtJyhYKT1mKG0pXFxcXCBcXGluIFxcbWF0aGNhbHtSfV9xIl0sWzAsMywiXFxib2xkc3ltYm9sIHonPWYoXFxib2xkc3ltYm9sIHopXFxcXCBcXGluIFxcbWF0aGJie0N9XntOLzJ9Il0sWzAsMSwiXFxvcGVyYXRvcm5hbWV7RW5jb2RlfSJdLFsxLDIsIlxcb3BlcmF0b3JuYW1le0VuY3J5cHR9Il0sWzIsMywiXFxvcGVyYXRvcm5hbWV7Q29tcHV0ZX0gZiJdLFszLDQsIlxcb3BlcmF0b3JuYW1le0RlY3J5cHR9Il0sWzQsNSwiXFxvcGVyYXRvcm5hbWV7RGVjb2RlfSJdXQ==
% \[\begin{tikzcd}
% 	{\boldsymbol{z}\\ \in\mathbb C^{N/2}} && {m(X)\\ \in \mathcal R_q} && {c=(c_1(X),c_2(X))\\ \in\mathcal R_q^2} \\
% 	\\
% 	\\
% 	{\boldsymbol z'=f(\boldsymbol z)\\ \in \mathbb{C}^{N/2}} && {m'(X)=f(m)\\ \in \mathcal{R}_q} && {c'= \operatorname{Eval}(f,c)\\ \in\mathcal{R}_q^2}
% 	\arrow["{\operatorname{Encode}}", from=1-1, to=1-3]
% 	\arrow["{\operatorname{Encrypt}}", from=1-3, to=1-5]
% 	\arrow["{\operatorname{Compute} f}", from=1-5, to=4-5]
% 	\arrow["{\operatorname{Decrypt}}", from=4-5, to=4-3]
% 	\arrow["{\operatorname{Decode}}", from=4-3, to=4-1]
% \end{tikzcd}\]

The scheme requires a process called \textit{relinearization} after each multiplication, introduced by BFV scheme \cite{bfv12} and also used in CKKS. Directly multiplying two ciphertexts $\boldsymbol c =(c_1,c_2)$ and $\boldsymbol c'=(c'_1,c'_2)$ yields a vector in $(d_0,d_1,d_2)\in \mathcal{R}_q^3$ where:
\begin{align*}
    d_0 & = c_1\cdot c'_1\\
    d_1 & = c_1\cdot c'_2 + c_2\cdot c'_1\\
    d_2 & = c_2\cdot c'_2
\end{align*}
The goal of relinearization is to transform the above triple into an equivalent tuple, i.e., a tuple that approximately preserves the decryption correctness. This process is also used in BFV and BGV schemes; although is quite expansive and introduces additional noise, it avoids ciphertext size growth, keeping it as a two-dimensional vector of polynomials.

The original HEAAN scheme was not fully homomorphic but a somewhat homomorphic one. Following Gentry's blueprint \cite{gentry2009fully}, to transform it into an FHE scheme, we should be able to evaluate the decryption circuit homomorphically, which is still an open problem for CKKS. Instead, the authors later proposed an \textit{approximate bootstrapping} procedure \cite{ckks_bootstrapping}, which follows Gentry's idea, but with an approximate decryption function. The consequence is that we lose precision after each bootstrap evaluation, but for statistical purposes, that's not a problem as long as we can control this approximation error.

\subsection{Encoding and Decoding}

The plaintext space, as we described before, is the cyclotomic ring $\Z[X]/(\Phi_M(X))$, with $M=2N$ and $N$ power of two. Our goal is to map complex $N/2$-dimensional\footnote{The reason for this dimension will soon become clearer.} vectors $\boldsymbol z\in\mathbb C^{N/2}$ into elements of the ring (encoding) and vice-versa (decoding).

We begin with the \textit{canonical embedding map}:
\begin{align*}
    \sigma &: \mathbb{C}[X]/(X^N+1)\longrightarrow\mathbb C ^N\\
    m(X)&\longrightarrow (m(\zeta_M),m(\zeta_M^3),\ldots,m(\zeta_M^{2N-1})),\\
    &\text{with }\zeta_M=\exp(2\pi i/M)
\end{align*}

The above map takes a polynomial with complex coefficients and evaluates it in the $M^{th}$ primitive roots of unity. Since $M$ is a power of two, from Definition \ref{def:prim_roots}, the primitive roots will be the $\zeta_M^k$ for $1\leq k\leq M$ with $\gcd(k, M)=1$, hence, $k$ ranges through the first $N$ odd numbers. The output is indeed a $N$- dimensional complex vector since both the polynomial coefficients and the primitive roots are complex.

An interesting fact is that $\sigma$ is an isomorphism, and we can use its inverse $\sigma^{-1}$ to encode a vector in $\boldsymbol{z}\in\mathbb C^N$ to a polynomial in $m(X)\in\C[X]/(\Phi_M(X))$. Recall that $m(X)$ can be written as $m(X)=\sum_{j=0}^{N-1}\alpha_jX^{j}$; So to construct $\sigma^{-1}$ we must be able to take $\boldsymbol z= (z_1,\ldots,z_N))^T$ and return the coefficients $(\alpha_j)_{j=0,1,\ldots,N-1}$ such that $(m(\omega_1),m(\omega_3),\ldots,m(\omega_{2N-1}))^T=\boldsymbol z$, where $\omega_k=\zeta_M^k$ to simplify notation. This can be viewed as a linear system:
\begin{align*}
    \displaystyle m(\omega_{2k-1})&=\sum_{j=0}^{N-1}\alpha_j\omega_{2k-1}^j=z_k\\
    &\text{for }k=1,2,\ldots,N;
\end{align*}
or as its matrix form:
\begin{align*}
    &~~~~~A\boldsymbol \alpha = \boldsymbol z,\\
    \text{with }A = &\left[\begin{matrix}
        1 & \omega_1 &\omega_1^2 &\ldots&\omega_1^{N-1}\\
        1 & \omega_3 &\omega_3^2 &\ldots&\omega_3^{N-1}\\
        1 & \omega_5 &\omega_5^2 &\ldots&\omega_5^{N-1}\\
        \vdots & \vdots &\vdots &\ddots&\vdots\\
        1 & \omega_{2N-1} &\omega_{2N-1}^2 &\ldots&\omega_{2N-1}^{N-1}
    \end{matrix}\right]\text{ and }\boldsymbol\alpha = \left[\begin{matrix}\alpha_0\\ \alpha_1\\ \alpha_2\\\vdots\\ \alpha_{N-1}\end{matrix}\right]
\end{align*}
The matrix $A$ is the Vandermonde matrix for the primitive roots $\omega_k=\zeta_M^k$, and has a known inverse \cite{vandermonde}. Then, we can find the coefficients through $\boldsymbol\alpha = A^{-1}\boldsymbol z$, arriving to the inverse canonical embedding map:
\begin{align*}
\sigma^{-1}:~\mathbb{C}^N&\longrightarrow\C[X]/(X^N+1)\\
    \sigma^{-1}(\boldsymbol z) &= m(X),
\end{align*}

with $m(X)=\sum_{j=0}^{N-1}\alpha_jX^j$ and $\alpha_j=(A^{-1})_j\boldsymbol z$

The complex primitive roots are symmetrical conjugates. In Figure \ref{fig:roots_of_unity} for example $\omega_1=\overline{\omega_1}=\omega_7$, in general for the $M^{th}$ primitive roots, $\omega_j=\overline{\omega_{-j}}$, where $-j$ index is taken modulo $M$. Remember that, for decoding, the goal was to map $\ring=\Z[X]/(X^N+1)$ to $\C^{N/2}$. Until now, we have a map $\ring\to\C^{N}$. The image $\sigma(\ring)$ can be reduced to half its dimension, noticing that $m(\omega_j)=\overline{m(\omega_{-j})}:$
\begin{align}
    \overline{m(\omega_{-j})}&=\overline{\sum_{k=0}^{N-1}\alpha_k\omega_{-j}^k}\nonumber
    =\sum_{k=0}^{N-1}\overline{\alpha_k\omega_{-j}^k}\nonumber\\
    &=\sum_{k=0}^{N-1}\alpha_k\overline{\omega_{-j}^k}\label{eq:real_conj}\\
    &=\sum_{k=0}^{N-1}\alpha_k\omega_{j}^k\nonumber=m(\omega_j)\nonumber
\end{align}
Equality \ref{eq:real_conj} holds because $\alpha_k\in\Z\subset\mathbb{R}$ so it does not affect the conjugate operator. Hence we have proved that the image $\sigma(\ring)$ are vectors in $\C^{N}$ whose coordinate $j$ are complex conjugates of coordinate $-j$. We can define now the subring $\mathbb{H}\subseteq \C^{N}$ as:
$$\Hr=\{(z_j)_{j\in\Z_M^*};z_j=\overline{z_{-j}},~\forall j\in \Z_M^*\},$$
where $\Z_M^*=\{k\in\Z;\gcd(k,M)=1\}=\{1,3,5,\ldots,2N-1\}$. 

The image $\sigma(\ring)$ is actually in $\Hr$. So, we can define the projection $\pi:\Hr\to\C^{N/2}$ that takes a $N$-dimensional vector in $\Hr$ and outputs a $N/2$-dimensional one, removing conjugates elements. Naturally, we also define $\pi^{-1}:\C^{N/2}\to\Hr$ that do the opposite, expanding a vector including the conjugates of its elements. Then, the decoding procedure will be $\pi\circ\sigma:\ring\to\C^{N/2}$.

Encoding is not that trivial. Notice that the codomain of $\sigma^{-1}$ is $\C[X]/(X^N+1)$, so we cannot guarantee that the polynomials will have integer coefficients. The first step is expanding $\boldsymbol z\in \C^{N/2}$ to $\Hr$ through $\pi^{-1}(\boldsymbol z)$, but to guarantee that applying $\sigma^{-1}$ will return an integer polynomial, we need to project $\pi^{-1}(\boldsymbol z)$ to the image $\sigma(\ring)$ using some rounding process $\lfloor \pi^{-1}(\boldsymbol z)\rceil_{\sigma(\ring)}$. This will approximate $\pi^{-1}$ to a close element in $\sigma(\ring)$ so that applying the inverse map results in a ring element. For more details about rounding techniques, refer to \cite{ckks17} and \cite{toolkit}. 

For precision preservation purposes, the encoding procedure multiplies $\pi^{-1}(\boldsymbol z)$ by a predefined scaling factor $\Delta>1$. Then we define $\ecd$ (encode) and $\dcd$ (decode) functions as:
\begin{align*}
    \ecd&:\C^{N/2}\longrightarrow\ring\\
    \ecd(\boldsymbol z;\Delta) &= \sigma^{-1}(\lfloor\Delta\cdot \pi^{-1}(\boldsymbol z)\rceil_{\sigma(\ring)})\\
    \dcd&:\ring\longrightarrow\C^{N/2}\\
    \dcd(m;\Delta)&=\pi\circ\sigma(\Delta^{-1}\cdot m)
\end{align*}

\subsection{Encryption, Decryption, and Relinearization}

Now let's describe the concrete cryptographic primitives of the CKKS scheme. Fix an integer base $p$ and define $q_\ell = p^{\ell}q_0$ for some given $q_0\in\Z$. This is a \textit{leveled homomorphic encryption} scheme, with levels $0\leq\ell\leq L$; after each multiplication, we rescale the message to a lower level to control the size of noise. 

The notation $\Z_q$ will choose the representatives from $\Z\cap (q/2,q/2]$, and $[ \cdot ]_q$ applied to a polynomial means wrapping its coefficients modulo $q$. $\lambda$ is a security parameter, which known attacks taking $\Omega(2^\lambda)$.

The Discrete Gaussian distribution $\dg(\sigma^2)$ over the polynomial ring $\ring$ samples the coefficients from a discrete gaussian with variance $\sigma^2$ over $\Z^N$ \cite{ckks17}; We'll use this distribution for sampling RLWE errors. Another useful distribution is $\zo(\rho)$ over $\ring_3=\Z_3[X]/(X^N+1)$, i.e., the polynomials with degree up to $N-1$ with coefficients in $\{0,\pm1\}$. $\zo(\rho)$ draws $N$ samples with probability $1-\rho$ of being zero and $\rho/2$ of being $+1$ or $-1$, this becomes the coefficients of the polynomial in $\ring_3$.

\begin{itemize}
    \item $\operatorname{KeyGen}(\lambda)$- Given a security parameter $\lambda$, chooses cyclotomical dimension $M=M(\lambda)$, error standard deviation $\sigma=\sigma(\lambda)$ and an integer $P=P(\lambda)$.
    
    Samples $s\leftarrow \ring_3$, $a\xlongleftarrow[]{\mathcal U}\mathcal{R}_{q_L}$ and $e\xlongleftarrow[]{\dg(\sigma^2)}\ring$.
    
    Set $\sk = (1,s)$ and $\pk = (b,a)$, with $b=\modulo[q_L]{-a\cdot s +e}$. Security of public key exposure is guaranteed by RLWE (Def. \ref{def:rlwe}).

    Samples $a'\xlongleftarrow[]{\mathcal U}\ring_{P\cdot q_L}$, $e'\xlongleftarrow[]{\dg(\sigma^2)}\ring$ and set the evaluation key $\evk=(b',a')$, with $b'=\modulo[P\cdot q_L]{-a'\cdot s+e'+P\cdot s^2}$. Its use will become clear soon, and security is also guaranteed by RLWE.

    \item $\enc(\pk,m)=\modulo[q_L]{v\cdot\pk+(m+e_0,e_1)},$ where $v\xlongleftarrow[]{\zo(0.5)}\ring_2$, and $e_0,e_1\xlongleftarrow[]{\dg(\sigma^2)}\ring$. Notice that the ciphertext is a two-dimensional vector of polynomials in $\ring_{q_L}$.

    \item $\dec(\sk,\boldsymbol c) = \modulo[q_\ell]{\langle\bd c,\sk\rangle}=\modulo[q_\ell]{c_1+c_2\cdot s}$, for $\boldsymbol c=(c_1,c_2)$ at level $\ell$.

    \item $\eval(+,\bd c,\bd c')=\modulo[q_\ell]{\bd c+\bd c'}$, for $\bd c,\bd c'\in\ring_{q_\ell}^2$

    \item $\eval(\evk,\times,\bd c,\bd c')=(d_0,d_1)+\lfloor P^{-1}\cdot d_2\cdot\evk\rceil(\bmod ~q_\ell)$, where for $\bd c=(c_1,c_2)$ and $\bd c'=(c'_1,c'_2)$, we have, as described before $(d_0,d_1,d_2)=(c_1\cdot c'_1,c_1\cdot c'_2 + c_2\cdot c'_1,c_2\cdot c'_2)$
\end{itemize}

The multiplication of ciphertexts is using a process called \textit{relinearizaton}, to reduce ciphertext dimension from $\ring^3_{q_\ell}$ to $\ring^2_{q_\ell}$. The goal is to find $(d_0^*,d_1^*)$ such that the decryption is approximately equivalent:
\begin{align*}
    \modulo[q_\ell]{d_0^*+d_1^*\cdot s}\approx\modulo[q_\ell]{d_0+d_1\cdot s+d_2\cdot s^2}
\end{align*}
In this case, $(d_0^*,d_1^*)=(d_0,d_1)+\lfloor P^{-1}\cdot d_2\cdot\evk\rceil(\bmod ~q_\ell)$ provides a ciphertext is an approximate valid encryption of the original multiplication of ciphertext \cite{ckks17}.

The levels $L$ define the maximum multiplicative depth the scheme allows because, after each multiplication, we rescale the ciphertext from $\ell\to\ell-1$ using:
$$\operatorname{Rescale_{\ell\to\ell'}}(\boldsymbol c) = \left\lfloor \dfrac{q_\ell'}{q_\ell}\bd c\right\rceil$$,

The intuition behind it is that each ciphertext has an embedded noise added by the encryption process, and multiplication increases it (exponentially!). the rescaling process controls the noise, reducing the ciphertext modulus and its built-in error. For more details, refer to \cite{rescale}.

Another useful operation permitted by the scheme is \textit{rotation} of plaintext slots, i.e., for a given $\bd z=(z_1,z_2,\ldots,z_{N/2})$ we can homomorphically apply a left rotation by $i$ for example, and output a ciphertext that encrypts $(z_i,z_{i+1},\ldots,z_{N/2},z_1,z_2\ldots,z_{i-1})$. Analogously a right rotation method can be constructed.

\subsection{Approximate Bootstrapping}

To make an FHE scheme out of the previously described leveled homomorphic one, we need bootstrapping, i.e., be able to evaluate the decryption function $\dec(\sk,\boldsymbol c) = \modulo[q_\ell]{\langle\bd c,\sk\rangle}$ using the homomorphic scheme. While a direct approach to homomorphically compute it is still an open problem, an \textit{approximate bootstrapping} was proposed by \cite{ckks_bootstrapping}. The idea comes from the fact that modular reduction operation can be represented by a trigonometric function:
\begin{align*}
    \modulo{\langle\bd c,\sk\rangle} = \dfrac{q}{2\pi}\cdot \sin\left(\dfrac{2\pi}{q}\cdot\langle \bd c,\sk\rangle\right) + O(\varepsilon^3\cdot q),
\end{align*} when $| \modulo{\langle\bd c,\sk\rangle}|\leq\varepsilon\cdot q$. CKKS scheme doesn't evaluate sine functions, it only permits additions and multiplications, so the authors used the Taylor expansion polynomial approximation, which can be represented as a composition of additions and multiplications.

\chapter{Private Logistic Regression}\label{ch:logit}
 In this chapter, we describe and test an algorithm for training a logistic regression model over encrypted data proposed in \cite{logreg}. Section \ref{sec:stat_rev} reviews basics statistic about classical logistic regression in plain data. Section \ref{sec:hom_train} describes how to adapt the training algorithm to the FHE setup. Finally, Section \ref{sec:data_app} show our experimental results.

\section{Statistical Review}\label{sec:stat_rev}

Logistic Regression is a probability model for binary class target variable. We have a dataset of $n$ observations of $d$ variables represented as a matrix $\boldsymbol X\in\mathbb{R}^{n\times d}$ and a target $n$-dimensional vector $\bd y\in\{0,1\}^n$.

For each observation $\bd x_i$ we have a corresponging binary responsing $y_i\in\{0,1\}$ that could mean a positive diagnosis for a disease in medical data, a credit default flag for in banking data or whether  an email is spam or not. Logistic regression models the probability of a true flag $p(\bd x)=\mathbb{P}(Y=1|X=\bd x)$ as if the log-odds were a linear function of $\bd x$:
$$\ln\left(\dfrac{p(\bd x)}{1-p(\bd x)}\right)=\bd w^T\bd x',$$
where $\bd w=(w_0,w_1,\ldots,w_d)^T\in\mathbb{R}^{d+1}$ is the vector of weights and $\bd x'=(1;\bd x)$ is an extended version of $\bd x$ with $1$ as the first element, to multiply by the bias term $w_0$. 
Isolating $p(\bd x)$, we get the model sigmoid model, for the probabilities:
$$p(\bd x)=\sigma(\bd w^T\bd x'),$$ where $\sigma(x)=1/(1+e^{-x})$.

The goal of the training algorithm is to find $\bd w$ that maximizes the bernoulli likelihood:
$$\displaystyle\mathcal{L}(\bd w)=\prod_{i=1}^n\sigma(\bd w^T\bd x'_i)^{y_i}(1-\sigma(\bd w^T\bd x'_i))^{1-y_i}$$

Observe that, the main part is $\sigma(\bd w^T\bd x'_i)$ if $y_i=1$ and $1-\sigma(\bd w^T\bd x'_i)$ if $y_i=0$. Transforming $y_i\in\{0,1\}$ to $y_i'=2y_i-1\in\{-1,+1\}$ and using the sigmoid property $\sigma(-x)=1-\sigma(x)$, we can rewrite the likelihood as:
$$\displaystyle\mathcal{L}(\bd w)=\prod_{i=1}^n\sigma(\bd w^T\bd z_i),$$ where $\bd z_i=\bd x'_i\cdot y'_i$. This trick will simplify the gradient calculation in the maximization process. In practice we minimize the negative log-likelihood:
\begin{align*}
    \ell(\bd w)&=-\dfrac{1}{n}\ln(\mathcal{L}(\bd w))\\
    &=-\dfrac1n\sum_{i=1}^n\ln(\sigma(\bd w^T\bd z_i))
\end{align*}
Since $\ln$ is a convex function in we can minimize it using the gradient descent iterative algorithm:
\begin{align*}
    \bd w_{i+1}=\bd w_i-\alpha\nabla\ell(\bd w_i),
\end{align*} for a given learning rate $\alpha>0$

Using $\sigma'(x)=\sigma(x)\sigma(-x)$, we can calculate the gradient:
\begin{align*}
    \nabla\ell(\bd w)&=-\dfrac1n\sum_{i=1}^n\nabla \ln(\sigma(\bd w^T\bd z_i)\\
    &=-\dfrac1n\sum_{i=1}^n\dfrac{\nabla\sigma(\bd w^T\bd z_i)}{\sigma(\bd w^T\bd z_i)}\\
    &=-\dfrac1n\sum_{i=1}^n\dfrac{\sigma'(\bd w^T\bd z_i)\bd z_i}{\sigma(\bd w^T\bd z_i)}\\
    &=-\dfrac1n\sum_{i=1}^n\sigma(-\bd w^T\bd z_i)\bd z_i
\end{align*}

Summarizing, a classical logistic regression training algorithm initializes $\bd w_0$ and then it update the weights by:
\begin{align}
    \bd w_{i+1}&=\bd w_i-\alpha\nabla\ell(\bd w_i),\nonumber\\
   \text{where }\nabla\ell(\bd w_i)&=-\dfrac1n\sum_{j=1}^n\sigma(-\bd w_i^T\bd z_j)\bd z_j\label{eq:gradient}
\end{align}
\section{Homomorphic Training}\label{sec:hom_train}

To adapt the training algorithm to an FHE-friendly setup \cite{logreg} used three main ingredients:
\begin{alineas}
    \item Mini-batch gradient descent: The gradient is calculated over a subset of the data instead of single elements or the whole dataset. Effectively, the sum in equation \ref{eq:gradient} doesn't range from 1 to $n$, but in a predetermined subset of indexes. Such a procedure can take advantage of the message encoding process described in the previous chapter, while limiting circuit depth.
    \item Nesterov Accelerated Gradient (NAG) Optimizer: Instead of conventional gradient descent, we'll use the NAG variant:
\begin{align*}
    \bd w_{i+1}&=\bd v_i-\gamma \nabla\ell(\bd  v_i)\\
    \bd v_{i+1}&=(1-\eta)\bd w_{i+1}+\eta \bd w_{i},
\end{align*} where $\gamma$ and $\eta$ are parameters that must be set by the user.
 \item Polynomial approximation for sigmoid: It's impossible to homomorphically evaluate $e^{-x}$ exactly, so the authors propose using a polynomial approximation for the sigmoid function, fitted using least squares minimization. The degree $3$ estimate that will be used in our tests is $\sigma_2(x)=0.5+0.15x+-0.0015x^3$, and it's the polynomial has the least square distance to the actual sigmoid in the interval $[-8,8]$ (Figure \ref{fig:sigmoid}). It's desirable to have a low-degree polynomial to save multiplications, and a cubic function provides a decent estimate.
\end{alineas}
\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.20]{files/figures/sigmoid.png}
    \caption{Sigmoid polynomial approximation}
    \label{fig:sigmoid}
\end{figure}

Then the first version of the algorithm can be formalized:

\begin{algorithm}[!htb]
    \caption{Approximate mini-batch training through NAG \cite{logreg}}\label{alg:alg1}
    \begin{algorithmic}[1]
        \REQUIRE{Mini-batches $\{Z_i\}$ where $Z_i\in\mathbb{R}^{m\times (d+1)}$, parameter $\gamma,\eta$, number of iterations $K$ and an approximate sigmoid $\sigma_2$}
\ENSURE{Weight vectors $\bd w,\bd v\in\mathbb{R}^{d+1}$}
 \STATE Initializes $\bd w,\bd v\leftarrow \bd 0$;
 \FOR{$k$ in $1,\ldots,K$}
  \STATE Select a mini-batch $Z_i$ (in order or at random)
  \STATE $\bd a = Z_i\cdot \bd v$
  \FOR{$j$ in $1,\ldots,m$}
  \STATE $b_j=\sigma_2(a_j)$
  \ENDFOR
  \STATE $\bd\Delta=\sum_{j=0}^{ m-1}b_j\cdot Z_i[j]$
  \STATE $\bd w^{+}=\bd v-\gamma \bd \Delta$
  \STATE $\bd v^{+}=(1-\eta)\bd w^{+}+\eta\bd w$
  \STATE $\bd w=\bd w^{+},~\bd v = \bd v^{+}$
 \ENDFOR
    \end{algorithmic}
\end{algorithm} 

Notice that the gradient 
Steps 4-7 calculate the sigmoidal part of the gradient, and step 8, effectively compute it. Steps 9-10 correspond to the NAG updates. 

\subsection{Ciphertext packing and data representation}
Let $\boldsymbol Z$ be the $n\times(d+1)$ matrix where the columns are $\bd z_j=\bd x'_j\cdot y'_j$, and $x_{i,j}$ the $i^{th}$ elements of $\bd x_j$. Denote $\bd Z = [\bd y',~\bd x'_1,~\bd x'_2,~\ldots,~x'_d]$ or, more explicitly:
$$\bd Z=\left[\begin{matrix}
    z[0][0] & z[0][1] & \ldots & z[0][d]\\
    z[1][0] & z[1][1] & \ldots & z[1][d]\\
    \vdots  &  \vdots & \ddots & \vdots \\
    z[n-1][0] & z[n-1][1] & \ldots & z[n-1][d]
\end{matrix}\right]$$ where $z[i][0]=y_i'$ and $z[i][j+1]=\bd y_i'\cdot x_{i,j}$, for $0\leq i\leq n-1$ and $0\leq j\leq d-1$

Instead of encrypting each element of $\bd Z$ separately, we partition the data in $m\times g$ submatrices and encrypt each block as a unique ciphertext:
\begin{align}\label{eq:zij}Z_{i,j}=\left[\begin{matrix}
    z[mi][gj] & \ldots & z[mi][gj+(g-1)]\\
    z[mi+1][gj] & \ldots & z[mi+1][gj+(g-1)]\\
    \vdots  & \vdots & \vdots \\
    z[mi+(m-1)][gj] & \ldots & z[mi+(m-1)][gj+(g-1)]
\end{matrix}\right],\end{align} for $0\leq i<n/m$ and $0\leq j <(d+1)/g$

Then we linearize (by row) the above matrix and transform it into a $mg$-dimensional real (so complex) vector $\bd p_{i,j}$. We then encrypt $\bd p_{i,j}$ using the scheme described in the previous chapter. The size of the blocks $m$ and $g$ are chosen such that $mg=N/2$, where $N/2$ is the dimension of encoding space $\C^{N/2}$. 

Notice that this packing technique produces $n(d+1)/mg$ ciphertexts instead of $n(d+1)$ of a naive elementwise encoding approach.

The NAG weight vectors $\bd w$ and $\bd v$ are also partitioned into $(d+1)/g$ sub-vectors and represented by a $m\times g$ matrix of $m$ copies of the sub-vector. So the $j^{th}$ sub-vector will corresponds to :
$$W_j=\left[\begin{matrix}
    w[gj] & w[gj+1] & \ldots & w[gj+(g-1)]\\
    w[gj] & w[gj+1] & \ldots & w[gj+(g-1)]\\
    \vdots  & \vdots & \vdots &\vdots \\
    w[gj] & w[gj+1] & \ldots & w[gj+(g-1)]\end{matrix}\right],$$
and $V_j$ is defined analogously. The encryption works as in $Z_{i,j}$

\subsection{Batch Inner Product}

Recall from Algorithm \ref{alg:alg1} that the training phase requires evaluating two inner products (steps 4 and 8). The two steps will take $O(g^2)$ multiplications and $O(g)$ additions. To make these steps more FHE-friendly and its multiplicative complexity \cite{logreg} introduced a batching technique that requires only two SIMD multiplications ($O(1)$) and $O(\log g)$ SIMD additions, using the matrix representation described before.

Given $Z\in \mathbb{R}^{m\times g},\bd v\in\mathbb{R}^{g}$, our goal is to homomorphically calculate $Z\cdot\bd v$. Let $V\in\mathbb{R}^{m\times g}$ be the matrix of $m$ copies of $\bd v$; if we encrypt $Z$ and $V$ in a row-linearization style and homomorphically multiply them, we get an encryption of the Hadamard product (elementwise):
$$Z\circ V=\left[\begin{matrix}
    Z[1][1]\cdot v[1] & Z[1][2]\cdot v[2] &\ldots& Z[1][g]\cdot v[g]\\
    Z[2][1]\cdot v[1] & Z[2][2]\cdot v[2] &\ldots& Z[2][g]\cdot v[g]\\
    \vdots &\vdots &\ddots &\vdots\\
    Z[m][1]\cdot v[1] & Z[m][2]\cdot v[2] &\ldots& Z[m][g]\cdot v[g]\\
\end{matrix}\right]$$
Given this result, we just have to sum its columns, which can be done through rotations combined with additions. Let $\operatorname{Lrot}_i(A)$ be the matrix whose elements are rotated $i$ places to the left (thinking in the linearized vector of $A$). Without loss of generality, assume that $g$ is a power of two, if that's not the case, we can append zeros to it. Defines $A^{(1)}=Z\circ V$, the desired inner product is the first column of $A^{(g)}$ which is updated through the following $(\log g)$-step iterative process:
\begin{align}\label{eq:inner}
A^{(2^{k+1})}&=A^{(2^k)}+\operatorname{Lrot}_{2^k}(A^{(2^k)})
\end{align}
It's not difficult to prove that:
$$A^{(2^{k+1})}_1=\left[\begin{matrix}
    \sum_{i=1}^{2^{k+1}}Z[1][i]\cdot v[i]\\
    \sum_{i=1}^{2^{k+1}}Z[2][i]\cdot v[i]\\
    \vdots\\
    \sum_{i=1}^{2^{k+1}}Z[m][i]\cdot v[i]
\end{matrix}\right],$$

which directly implies $A^{(g)}=Z\cdot\bd v$ as wanted. 
To get a better idea of what \ref{eq:inner} is doing, let's work in a $4$-dimensional example: Denote $A^{(1)}=Z\circ V$ as $[\bd a_1,~\bd a_2,~\bd a_3,~\bd a_4]$ for simplicity.
\begin{itemize}
    \item Iteration $k=0$, Compute $A^{ (2)}$:
\begin{align*}
    A^{(2)} &= A^{1}+\operatorname{Lrot}_1(A^{(1)})\\
    & = [\bd a_1,~\bd a_2,~\bd a_3,~\bd a_4]\\
    &~+[\bd a_2,~\bd a_3,~\bd a_4,\bd a_1]\\
    &=[\bd a_1+\bd a_2,~\bd a_2+\bd a_3,~\bd a_3+\bd a_4,~\bd a_4+\bd a_1]
\end{align*}
\item Iteration $k=1$, Compute $A^{ (4)}$:
\begin{align*}
    A^{(4)} &= A^{2}+\operatorname{Lrot}_2(A^{(2)})\\
    & = [\bd a_1+\bd a_2,~\bd a_2+\bd a_3,~\bd a_3+\bd a_4,~\bd a_4+\bd a_1]\\
    &~+[\bd a_3+\bd a_4,~\bd a_4+\bd a_1,\bd a_1+\bd a_2,~\bd a_2+\bd a_3]\\
    &=[\bd a_1+\bd a_2+\bd a_3+\bd a_4,\ldots]
    \end{align*}
\end{itemize}

Notice that until now, only one multiplication was used. The complete result of $A^{(g)}$ from Recurrence \ref{eq:inner} is actually a $m\times g$ matrix, where the columns after the first are not important. To clean it out, we use another SIMD multiplication by a mask matrix $[\bd1~\bd0~\ldots~\bd0]$ and use a similar procedure of rotation-addition as the above one to replace the null entries by replicates of the first column. The total multiplicative cost of the batch inner product is then $2$.

The procedure of summing columns, removing garbage by the zero mask, and propagating first column entries, is defined as a separated algorithm for \cite{logreg}: $\operatorname{SumColVec}$, returning :
$$\operatorname{SumColVec}(A)=\left[\begin{matrix}
    \sum_ja_{1j}&\ldots&\sum_ja_{1j}\\
    \sum_ja_{2j}&\ldots&\sum_ja_{2j}\\
    \vdots&\ddots&\vdots\\
    \sum_ja_{mj}&\ldots&\sum_ja_{mj}
\end{matrix}\right],$$
 for $A\in\mathbb{R}^{m\times g}$. The desired inner product is then $\operatorname{SumColVec}(Z\circ V)$, actually a matrix of duplicates $g$ duplicates of it. Similarly, the $\operatorname{SumRowVec}$ algorithm returns a matrix with $m$ replicates of the sum over $A$ rows, using an analogous process of SIMD operations. 

Now we have all tools to redefine the loop of Algorithm \ref{alg:alg1} to its vectorized form described in Algorithm \ref{alg:alg2}. 

Notation: For a fixed iteration $k=i$, $\Z_j=Z_{i,j}$ as in equation \ref{eq:zij}. A bolded number or constant denotes the $m\times g$ matrix of its replicates. $M^{\circ \,n}$ is the result of $n$ nested Hadamard products of $M$: its elements are $M^{\circ \,n}_{i,j}=M^n_{i,j}$

\begin{algorithm}[!htb]
    \caption{Vectorized weights update \cite{logreg}}\label{alg:alg2}
    \begin{algorithmic}[1]
        \REQUIRE{Matrices $Z_j,W_j,V_j\in\mathbb{R}^{m\times g}$, for $0\leq j <(d+1)/g$}
\ENSURE{Matrices $W_j^+,V_j^+$, for $0\leq j <(d+1)/g$}
 \FOR{$0\leq j <(d+1)/g$}
    \STATE $M_j=Z_j\circ V_j$
    \STATE $M_j=\operatorname{SumColVec}(M_j)$
 \ENDFOR
 \STATE $M=\sum_{j}M_j$
 \STATE $S=\bd {0.5}+\bd{0.15}\circ M-\bd{0.0015}\circ M^{\circ3}$
 \FOR{$0\leq j<(d+1)/g$}
 \STATE $S_j=S\circ Z_j$
 \STATE $\Delta_j=\operatorname{SumRowVec(S_j)}$
 \STATE $W_j^{+}=V_j-\bd\gamma\circ\Delta_j$
 \STATE $V_j^{+}=(\bd1-\bd\eta)\circ W_j^{+}+\bd\eta\circ  W_j$
 \ENDFOR
 \RETURN{$W_j^{+},V_j^{+}$ for $0\leq j <(d+1)/g$}
    \end{algorithmic}
\end{algorithm} 

After batch choice in the first algorithm, Algorithm \ref{alg:alg2} starts. Steps 1-4 calculates the first inner product; Step 5 sums the results over $j$, since for a particular $j$, we are dealing with just a subset (of size $g$) of data columns. Step 6 evaluates the approximate sigmoid function, and finally, loop 7-12 calculates the gradient and updates weights for all columns batches $j$. 

All the operations in Algorithm \ref{alg:alg2} can be efficiently computed over encrypted data, changing Hadamard products by encrypted multiplication over a linearized encrypted matrix, also we need to apply continuous apply bootstrapping after a given number of iterations to be able to correctly evaluates an arbitrary number of iterations. For further optimization details of this algorithm and the exact FHE formulation, the reader can refer to \cite{logreg}. 

\section{Data Applications}\label{sec:data_app}

The HEAAN scheme is implemented in a C++ package also named HEAAN \cite{heaan}. It supports all cryptographic primitives and bootstrapping. The logistic regression algorithm we describe in the previous chapter was implemented by the authors in the C++ package HELR \cite{helr}, which uses HEAAN package as the FHE base.

We tested the algorithm in the TissueMNIST dataset, which is part of the dataset collection from MedMNIST dataset \cite{medmnistv2}. The original version has $28\times28$ images of kidney cortex cells labeled in eight classes. We adapt the dataset by compressing\footnote{using the simple mean of the pixels} the images to a smaller $14\times14$ set and transform it into a binary classification problem choosing only samples from two classes: ``Collecting Duct'' and ``Proximal Tubule Segments'' (Figure \ref{fig:tissue})

\begin{figure}[!htb]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=0.9]{files/figures/medmnist0.png}
  \caption{Collecting Duct}
  \label{fig:med0}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=0.9]{files/figures/medmnist6.png}
  \caption{Proximal Tubule Segments}
  \label{fig:med6}
\end{subfigure}
\caption{TissueMNIST}
\label{fig:tissue}
\end{figure}

The images are matrixes of pixel values, so to train the model, we linearized them to $196$-dimensional vectors. Subsetting just the above two classes, we got $92672$ samples, with $\sim 90$ MB

The CKKS ring parameters were set as:
\begin{align*}
    N&=2^{15}\\
    q&=2^{45}
\end{align*}

With a total number of $50$ iterations, running bootstrapping every $3$ iterations, using a computer with a 64-bit quad-core Intel Core i5-6200U 2.3GHz CPU, and 16GB of RAM, we got the following results:

\begin{table}[!htb]
    \centering
    \begin{tabular}{|c|c|}\hline 
        KeyGen time &  8.52 min\\ \hline
         Encrypt time & 19.17 min \\ \hline
         Training time & 6.19 hours \\ \hline
         Public key size & 2.62 GB \\ \hline
    \end{tabular}
    \caption{FHE performance}
    \label{tab:fhe_perf}
\end{table}

An important note is that 47\% of training time was spent in bootstrapping.

In terms of the model, after 50 iterations, we got the following metrics:
\begin{table}[!htb]
    \centering
    \begin{tabular}{|c|c|c|}\hline
    & Encrypted & Unencrypted \\ \hline   
        Accuracy & 64.6211\% & 64.6363\%\\ \hline
         AUC & 81.7039\% & 81.6996\% \\ \hline
    \end{tabular}
    \caption{Model Performance}
    \label{tab:model}
\end{table}

By unencrypted, we mean Algorithm \ref{alg:alg2} applied to unencrypted data (with approximate sigmoid). Notice that encrypted/unencrypted metrics are very close; This result shows us that the noise introduced by encryption, homomorphic evaluation, and bootstrapping is negligible regarding model performance.





